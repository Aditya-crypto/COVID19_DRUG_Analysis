# -*- coding: utf-8 -*-
"""COVID19TL.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/18dJX7ie3OMlO9y6RojoasPSjV3mWgdcv
"""

!pip install git+https://github.com/samoturk/mol2vec;

# Install RDKit. Takes 2-3 minutes
!wget -c https://repo.continuum.io/miniconda/Miniconda3-latest-Linux-x86_64.sh
!chmod +x Miniconda3-latest-Linux-x86_64.sh
!time bash ./Miniconda3-latest-Linux-x86_64.sh -b -f -p /usr/local
!time conda install -q -y -c conda-forge rdkit

import sys
sys.path.append('/usr/local/lib/python3.7/site-packages/')

from rdkit import Chem
from rdkit.Chem import Draw
from rdkit.Chem.Draw import IPythonConsole
from rdkit.Chem import Descriptors
from rdkit.Chem import AllChem
from rdkit import DataStructs
import numpy as np
import pandas as pd
from rdkit import Chem
from rdkit.Chem import ChemicalFeatures
from rdkit import RDConfig
import os

df= pd.read_csv('/content/drive/My Drive/A5Q3DB/train.csv')
target = df['Binding Affinity']
df.drop(columns='Binding Affinity',inplace=True)
print(df)

Finaltestdata=pd.read_csv('/content/drive/My Drive/A5Q3DB/f_test.csv')
print(Finaltestdata)


# import tensorflow as tf
# import tensorflow.keras as keras
# from keras import Model
# from keras.layers import Activation, Dense, Dropout, Input
# from keras.utils import np_utils
  



"""## Using Pretrained Model"""

from mol2vec.features import mol2alt_sentence, mol2sentence, MolSentence, DfVec, sentences2vec
from gensim.models import word2vec
from gensim.models import word2vec
model = word2vec.Word2Vec.load('/content/drive/My Drive/model_300dim.pkl')

def create_dataset(df):
  df['mol'] = df['SMILES sequence'].apply(lambda x: Chem.MolFromSmiles(x))
  df['sentence'] = df.apply(lambda x: MolSentence(mol2alt_sentence(x['mol'], 1)), axis=1)
  df['mol2vec'] = [DfVec(x) for x in sentences2vec(df['sentence'], model, unseen='UNK')]
  dataset= np.array([x.vec for x in df['mol2vec']])
  return dataset

dataset=create_dataset(df)

Finaltest=create_dataset(Finaltestdata)

def create_file(predictLabels,testdata):
  smiles=testdata['SMILES sequence'] 
  list_of_tuples = list(zip(smiles, predictLabels))  
  sub = pd.DataFrame(list_of_tuples, columns = ['SMILES sequence', 'Binding Affinity'])   
  print(sub)
  sub.to_csv('submission.csv')


df=pd.read_csv('/content/drive/My Drive/A5Q3DB/train.csv')

Finaltestdata=pd.read_csv('/content/drive/My Drive/A5Q3DB/f_test.csv')

def number_of_atoms(atom_list, df):
    for i in atom_list:
        df['num_of_{}_atoms'.format(i)] = df['molecule'].apply(lambda x: len(x.GetSubstructMatches(Chem.MolFromSmiles(i))))

def add_features(df):
  df['molecule'] = df['SMILES sequence'].apply(lambda x:Chem.MolFromSmiles(x))
  df['molecule'] = df['molecule'].apply(lambda x: Chem.AddHs(x))
  df['num_of_atoms'] = df['molecule'].apply(lambda x: x.GetNumAtoms())
  df['num_of_heavy_atoms'] = df['molecule'].apply(lambda x: x.GetNumHeavyAtoms())
  df['SSSR'] = df['molecule'].apply(lambda x:len(Chem.GetSymmSSSR(x)))
  # df['rings1']=df['molecule'].apply(lambda x: x.GetRingInfo().NumAtomRings(1))
  df['rings2']=df['molecule'].apply(lambda x: x.GetRingInfo().NumAtomRings(2))
  df['in_rings']=df['molecule'].apply(lambda x: x.GetAtomWithIdx(1).IsInRing())
  df['ringsize3']=df['molecule'].apply(lambda x: x.GetAtomWithIdx(2).IsInRingSize(3))
  df['isAromatic']=df['molecule'].apply(lambda x: x.GetBondWithIdx(1).GetIsAromatic())
  df['tpsa'] = df['molecule'].apply(lambda x: Descriptors.TPSA(x))
  df['mol_w'] = df['molecule'].apply(lambda x: Descriptors.ExactMolWt(x))
  df['num_valence_electrons'] = df['molecule'].apply(lambda x: Descriptors.NumValenceElectrons(x))
  # df['num_heteroatoms'] = df['molecule'].apply(lambda x: Descriptors.NumHeteroatoms(x))
  # df['num_rotable_bonds'] = df['molecule'].apply(lambda x: Descriptors.NumRotatableBonds(x))
  # df['num_amide_bonds'] = df['molecule'].apply(lambda x: Descriptors.NumAmideBonds(x))
  # df['num_SpiroAtoms'] = df['molecule'].apply(lambda x: Descriptors.NumSpiroAtoms(x))
  df['num_Fraction'] = df['molecule'].apply(lambda x: Descriptors.FractionCSP3(x))
  # # df['geometry'] = df['molecule'].apply(lambda x: Descriptors.Autocorr2D(x))
  # df['num_BridgeheadAtoms'] = df['molecule'].apply(lambda x: Descriptors.NumBridgeheadAtoms(x))
  # df['num_rotable bonds'] = df['molecule'].apply(lambda x: Descriptors.FractionCSP3(x))
  number_of_atoms(['C','O', 'N','S', 'Cl'], df)
  return df

# #EXTRA FEATURES THAT ARE OPTIONAL
# fdefName = os.path.join(RDConfig.RDDataDir,'BaseFeatures.fdef')
# factory = ChemicalFeatures.BuildFeatureFactory(fdefName)
# df['feats'] = df['molecule'].apply(lambda x:len(factory.GetFeaturesForMol(x)))
# df['featsfamily'] = df['molecule'].apply(lambda x:factory.GetFeaturesForMol(x)[0].GetFamily())
# df['featstype'] = df['molecule'].apply(lambda x:factory.GetFeaturesForMol(x)[0].GetType())
# df['feats1family'] = df['molecule'].apply(lambda x:factory.GetFeaturesForMol(x)[1].GetFamily())


df=add_features(df)

testData=add_features(Finaltestdata)

train_df = df.drop(columns=['SMILES sequence', 'molecule', 'Binding Affinity'])

final_df=testData.drop(columns=['SMILES sequence', 'molecule', 'Binding Affinity'])

print(train_df.shape)


train_mdf = pd.DataFrame(dataset)
train_mdf = pd.concat((train_mdf, train_df), axis=1)

final_mdf= pd.DataFrame(Finaltest)
final_mdf = pd.concat((final_mdf, final_df), axis=1)

# new_df=pd.get_dummies(new_df, prefix=['featsfamily', 'feats1family', 'featstype'])

from sklearn.metrics import mean_absolute_error, mean_squared_error
from sklearn.linear_model import RidgeCV
from sklearn.model_selection import train_test_split

X_train, X_test, y_train, y_test = train_test_split(train_mdf, target, test_size=.1, random_state=2)

from numpy import array
from keras.preprocessing.text import Tokenizer
from keras.preprocessing.sequence import pad_sequences
from keras.models import Sequential
from keras.layers import Dense
from keras.layers import Flatten
from keras.layers.embeddings import Embedding
from keras.layers import LSTM
from sklearn.model_selection import train_test_split

X_train=np.array(X_train)
X_test=np.array(X_test)
y_train=np.array(y_train)
y_test=np.array(y_test)
print(type(X_train))

trainX= np.reshape(X_train,(X_train.shape[0], 1, X_train.shape[1]))
print(trainX.shape)


final_mdf=np.array(final_mdf)
final_test_data= np.reshape(final_mdf,(final_mdf.shape[0], 1, final_mdf.shape[1]))
print(final_test_data.shape)

from keras.layers import Conv1D, MaxPooling1D
from keras.layers import Dense, Dropout, Flatten

model = Sequential()

model.add(Conv1D(filters=8, kernel_size=3, padding='same', activation='relu'))

model.add(LSTM(200, input_shape=(1,316)))
model.add(Dense(64,activation='relu'))
# model.add(Dense(32,activation='relu'))
model.add(Dense(1))
model.compile(loss='mean_squared_error', optimizer='adam')
model.fit(trainX, y_train, epochs=100, batch_size=32, verbose=2)

testX= np.reshape(X_test,(X_test.shape[0], 1, X_test.shape[1]))
testPredict = model.predict(testX)
from sklearn.metrics import mean_absolute_error, mean_squared_error
mae = mean_absolute_error(y_test, testPredict)
mse = mean_squared_error(y_test,testPredict)
print('MAE score:', mae)
print('MSE score:', mse)

from sklearn.metrics import r2_score
r2_score(y_test,testPredict)


final_predict_labels = model.predict(final_test_data)

print(final_predict_labels)

final_predicted=[]
for i in range(0,len(final_predict_labels)):
  final_predicted.append(final_predict_labels[i][0])
create_file(final_predicted,Finaltestdata)

